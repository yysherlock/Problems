#1-7.2_generate_permutation.py:

    递归外套for循环依次遍历，一般为了达到递归终止条件，需要不断减少状态，直至递归返回，接着要恢复状态一遍for循环接着遍历。否则，上层递归函数的for循环会会OutOfIndex。

#1-7.2_generate_subset.py

增量法，subset每次选择一个元素增加，第i次/层迭代（for循环）增加有n-i+1中选择（从集合S中）。
想像的难点在于，正常思维是尝试遍第i个元素再尝试i+1 pos的情况，
比如：[],[1],[2],[3],[4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4],[1,2,3],[1,3,4],..
而实际上程序递归执行时是栈的形式也即dfs的感觉，
每个递归函数的作用是 借助它调用的子递归函数的for循环来 feed pos th处的元素 来完成任务的。所以每个递归函数需要给它的子递归函数提供遍历元素信息(selectpos)。
所以用 pos 来标识递归函数。
 [], 在pos 1th 可选 1,2,3,4                        	pos=0(已填0个)
     [1], 在pos 2th 可选 2,3,4				pos=1
         [1,2], 在 pos 3th 可选 3,4			pos=2
             [1,2,3], 在 pos 4th 可选4			pos=3
                 [1,2,3,4], 没有可选的了pop(-1)		pos=4
             [1,2,4], 返回上一层递归函数，填pos 3th,    pos=3
     	 [1,3], pop(-1) 并返回 pos=2 			pos=2
	     [1,3,4],
         [1,4],
     [2],
         [2,3],
	     [2,3,4],
	 [2,4],
     [3],
	 [3,4],
     [4],
	
位向量法，通过变化 bitmap 来得到不同的子集。
bitmap 长度固定，就是总集合 S 中元素的个数。
还是将子递归函数看成是父函数的 workhorse，这样想方便设计递归函数内容。
用 pos 标识递归函数层数，ith 递归层 选中/未选中 元素S[i]时，分别调用子递归函数继续构造bitmap。
1 0 0 0    pos = 0
1 1 0 0    pos = 1
1 1 1 0    pos = 2
1 1 1 1    pos = 3 print 
1 1 1 0    pos = 3 print
1 1 0 0    pos = 2 
1 1 0 1    pos = 3 print
1 1 0 0    pos = 3 print
以下均为 pos = 3 print 的情况
1 0 1 1
1 0 1 0
1 0 0 1
1 0 0 0
0 1 1 1
0 1 1 0
0 1 0 1
0 1 0 0
0 0 1 1
0 0 1 0
0 0 0 1
0 0 0 0


